# This file defines role-based access control for your Bolt site.
# Before making any modifications to this file, make sure you've thoroughly
# read the documentation at https://docs.bolt.cm/configuration/permissions
# and understand the consequences of making uninformed changes to the roles and
# permissions.

# roles that are presented in the list when editing a user 
# these will be filtered based on the user's own level to make sure you don't assign
# roles 'above' yourself. Any role you have yourself you can assign to others. 
# (This is assuming roles are defined in the symfony security config and ordered in a 
# hierarchy in config/packages/security.yaml)

# note: ROLE_USER is assigned to Bolt Entity Users if no roles have been set
# it is not included in this list as it should not be added/removed
# the assumption is that these roles are also defined in the symfony security role hierarchy
assignable_roles: [ROLE_ADMIN, ROLE_CHIEF_EDITOR, ROLE_EDITOR]
# some roles are not in the role hierarchy and/or not assigned to 'normal' back end users
# the default is to leave these roles 'as is'
# if they should be assignable you need to add them here, these roles can be assigned by 
# users with the global 'assign_unchecked_roles' permission (see below)
# for other users the behavior will be to leave them 'as is' and not show them when editing users
assignable_roles_unchecked: [ROLE_USER_FRONTEND_GROUP1, ROLE_USER_FRONTEND_GROUP2, ROLE_EXTRA_1, ROLE_EXTRA_14]

# These permissions are the 'global' permissions; these are not tied
# to any content types, but rather apply to global, non-content activity in
# Bolt's backend. Most of these permissions map directly to backend routes;
# keep in mind, however, that routes do not always correspond to URL paths 1:1.
# The default set defined here is appropriate for most sites, so most likely,
# you will not have to change it.
# Also note that the 'editcontent' and 'overview' routes are special-cased
# inside the code, so they don't appear here.
global:
    about: [ IS_AUTHENTICATED_ANONYMOUSLY ] # view the 'About Bolt' page
    clearcache: [ ROLE_ADMIN, ROLE_DEVELOPER ]
    dashboard: [ IS_AUTHENTICATED_FULLY ]
    extensions: [ ROLE_DEVELOPER ]
    # these control /bolt/file-edit and /bolt/filemanager -> combined create/read/update/delete permission
    # the part after the files: is the 'location' where the files are part of
    managefiles:config: [ ROLE_DEVELOPER ] # all configuration yml files /bolt/filemanager/config and /bolt/file-edit/config?file=/bolt/menu.yaml
    managefiles:files: [ ROLE_ADMIN ]
    managefiles:themes: [ ROLE_DEVELOPER ]
#    prefill: [ developer ]
    profile: [ IS_AUTHENTICATED_FULLY ] # edit own profile
#    settings: [ admin, developer, everyone ]
#    translation: [ developer ]
    user:list: [ ROLE_ADMIN ] # overview listing of users and a list of active sessions
    user:add: [ ROLE_ADMIN ] # add user - allows editing user _before_ saving, after saving 'useredit' is needed. -> cannot give roles above 'self'
    user:status: [ ROLE_ADMIN ] # user enable/disable -> cannot enable/disable users with roles above 'self'
    user:delete: [ ROLE_ADMIN ] # user delete -> cannot delete users with roles above 'self'
    user:edit: [ ROLE_ADMIN ] # user edit all fields, including status -> cannot give roles above 'self'
#    maintenance-mode: [ everyone ] # view the frontend when in maintenance mode
    omnisearch: [ IS_AUTHENTICATED_ANONYMOUSLY ]
#    # Access to the various logs
#    changelog: [ admin, developer, chief-editor ]
    systemlog: [ ROLE_ADMIN, ROLE_DEVELOPER ]
# NEW
    bulk_operations: [ ROLE_CHIEF_EDITOR ]
    kitchensink: [ ROLE_DEVELOPER ]
    upload: [ ROLE_EDITOR ] # upload media/files
    extensionmenus: [ IS_AUTHENTICATED_FULLY ] # allows you to see menu items added by extensions
    assign_unchecked_roles: [ ROLE_ADMIN ] # see above at assignable_roles_unchecked


# For content type related actions, permissions can be set individually for
# each content type. For this, we define three groups of permission sets.
# The 'contenttype-base' permission sets *overrides*; any roles specified here
# will grant a permission for all content types, regardless of the rest of this
# section.
# The 'contenttype-default' contains rules that are used when the desired
# content type does not define a rule for this permission itself.
# The 'contenttypes' section specifies permissions for individual content
# types.
#
# To understand how this works, it may be best to follow the permission checker
# through its decision-making process.
#
# First, it checks whether the current user is in the "root" role; if so, it
# short-circuits and always grants anything unconditionally.
#
# Otherwise, it checks whether any of the current user's roles match any of the
# roles in contenttype-base/{permission}. If so, the search is over, and the
# permission can be granted.
#
# The next step is to find contenttypes/{contenttype}/{permission}. If it is
# found, then the permission can be granted if and only if any of the user's
# roles match any role in contenttypes/{contenttype}/{permission}.
#
# If either contenttypes/{contenttype} or
# contenttypes/{contenttype}/{permission} is absent, the permission checker
# uses contenttype-default/{permission} instead. If any role exists in both the
# user's roles and contenttype-default/{permission}, the permission can be
# granted.
#
# Note especially that an *empty* set of roles in the contenttype section means
# something else than the *absence* of the permission. If the permission is
# defined with an empty role list, it overrides the role list in
# contenttype-default; but if the permission is not mentioned, the
# corresponding entry in contenttype-default applies.
#
# The following permissions are available on a per-contenttype basis:
#
# - edit: allows updating existing records
# - create: allows creating new records
# - change-status: allows changing the published status of a record
# - delete: allows (hard) deletion of records
# - change-ownership: allows changing a record's owner. Note that ownership may
#                     grant additional permissions on a record, so this
#                     permission can indirectly enable users more permissions
#                     in ways that may not be immediately obvious.
# - view: allows viewing records in the backend (listings, content/fields)



# these permissions will be set for all contenttypes, config below can add additional roles to these, but they can not be overridden
contenttype-base:
    edit: [ ROLE_ADMIN ]
    create: [ ROLE_ADMIN ]
    change-status: [ ROLE_ADMIN ]
    delete: [ ROLE_ADMIN ]
    change-ownership: [ ROLE_ADMIN ]
    view: [ ROLE_ADMIN ] # = show in menu, show listings, open 'edit' view without actually being able to edit, any of the other permissions always imply 'view'

# these permissions are used as a default for contenttypes, they are added to the base permissions 
# you can override these settings per contenttype by adding it to the `contenttypes:` array
contenttype-default:
    edit: [ ROLE_CHIEF_EDITOR, CONTENT_OWNER ]
    create: [ ROLE_CHIEF_EDITOR ]
    change-ownership: [ CONTENT_OWNER ] # <-- how to handle chance-ownership permission without 'edit'?
    view: [ ROLE_CHIEF_EDITOR ]
#    view: [ IS_AUTHENTICATED_FULLY ]
#    show-in-menu: [ IS_AUTHENTICATED_FULLY ] # <-- not a useful permission after all


contenttypes:

# This is an example of how to define Contenttype specific permissions
#
# contenttypes:
#    # Keys in this dictionary map to keys in the contenttypes.yml specification.
#    showcases:
#        # Rules defined here *override* rules defined in contenttype-default,
#        # but *add* to rules in contenttype-base. This means that permissions
#        # granted through contenttype-base cannot be revoked here, merely
#        # amended.
#
#        # Only the Admin and Chief Editor are allowed to edit records
#        edit: [ ROLE_CHIEF_EDITOR ]
#        create: [ ROLE_CHIEF_EDITOR ]
#        change-status: [ ROLE_CHIEF_EDITOR ]
#        delete: [ ROLE_CHIEF_EDITOR ]
#        show-in-menu: [ ROLE_CHIEF_EDITOR ]
    pages:
        edit: [ ROLE_EDITOR, CONTENT_OWNER ]
        create: [ ROLE_EDITOR ]
        change-ownership: [ CONTENT_OWNER ]
        view: [ ROLE_USER ]
#        view: [ IS_AUTHENTICATED_FULLY ]
#        show-in-menu: [ IS_AUTHENTICATED_FULLY ] #<-- not useful after all
